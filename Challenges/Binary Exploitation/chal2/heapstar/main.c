#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

void safe_puts(char * str,int newline){
    int i=0;
    while(str[i]!=0) write(1,&str[i++],1);
    if (newline){write(1,"\n",1);}
        
    
}

void safe_read(char *ptr , int size){
    if (size)
    {
        int i=0;
        for (i=0;i<size;i++) {
            read(0,&ptr[i],1);
            if (ptr[i]=='\n'){
                ptr[i]='\0';
                return;
            }
        }
        ptr[size-1]='\0';
    }
}

void setup(){
    setbuf(stdin,0);
    setbuf(stdout,0);
}



char ** elements=NULL;
size_t n_elements=0;
size_t counter=0;
int replaced=0;

void init_elements(){
    char tmp[0x50]={0};
    safe_puts("input number of elements in your tier list ",0);
    safe_read(tmp,sizeof(tmp));
    n_elements=atol(tmp);
    elements=malloc(n_elements*sizeof(void*));
    if (!elements){
        safe_puts("allocation failed",1);
        exit(-1);
    }
    //safe_puts("elements allocated successfully");
}

int get_long(){
    unsigned long x=0;
    char tmp[0x20];
    safe_read(tmp,sizeof(tmp));
    x=atol(tmp);
    return x;
}

void menu(){
    safe_puts("[1] create",1);
    safe_puts("[2] view",1);
    safe_puts("[3] delete",1);
    safe_puts("[4] replace",1);

}



#define CHUNK_SIZE 0x600

int write_chunk(size_t index){
    
    if (index >= counter){
        safe_puts("[-] not valid index",1);
        return 0;        
    }
    safe_puts("content : ",0);
    safe_read(elements[index],CHUNK_SIZE);
}
int create(){
    if (counter>=n_elements){
        safe_puts("[-] max allocations reached",1);
        return 0;
    }
    elements[counter]=malloc(CHUNK_SIZE);
    if (!elements[counter]){
        safe_puts("[-] element allocation failed",1);
        exit(-1);
    }
    memset(elements[counter],0,CHUNK_SIZE);
    write_chunk(counter++);
}

int show(){
    safe_puts("show : element index : ",0);
    size_t index=get_long();
    
    if (index >= counter){
        safe_puts("[-] not valid index",1);
        return 0;        
    }
    safe_puts("element : ",0);
    safe_puts(elements[index],1);
}

int delete(){
    safe_puts("delete : element index : ",0);
    size_t index=get_long();
    
    if (index >= counter){
        safe_puts("[-] not valid index",1);
        return 0;        
    }
    free(elements[index]);
    elements[index]=NULL;
    return 0;
}


int replace(){
    if (replaced){
        safe_puts("[-] upgrade to premium to get unlimited swaps",1);
        return 0;
    }
    safe_puts("1st element index : ",0);
    size_t index1=get_long();

    safe_puts("2nd element index : ",0);
    size_t index2=get_long();
    
    if (!(index1<counter | index2<counter)){
        safe_puts("[-] out of bound detected ",1);
        exit(-1);       
    }
    
    *(long*)(&elements[index1])^=(long)elements[index2];
    *(long*)(&elements[index2])^=(long)elements[index1];
    *(long*)(&elements[index1])^=(long)elements[index2];

    safe_puts("[+] you just used your free trial\n",1);
    replaced=1;
    
}



int main(){

    setup();
    
    safe_puts("welcome to Tas : Tierlist as a service",1);
    
    init_elements();
    int choice;
    while(1){
        menu();
        choice=get_long();
        switch (choice)
        {
            case 1:
                create();
                break;
            case 2:
                show();
                break;
            case 3:
                delete();
                break;
            case 4:
                replace();
                break;
            default:
                safe_puts("wrong choice",1);
                return 0;
        }
    }

}
